# Emuera 术语表

## 启动模式

### 普通模式 Normal Mode

这是Emuera正常启动时的模式。

当你双击EmueraXXXX.exe启动它时，你就会进入这种模式。

### 解析模式 Analysis Mode

这是以要解析的文件名作为命令行参数进行调用时的模式。

当你把一个文件拖到EmueraXXXX.exe上并启动它时，这个模式就被激活了。

分析模式检查你拖放的文件的语法。

这使你能够检查你正在开发的文件中是否有语法错误。

然而，由于需要检查字符串的规范，你需要确保脚本运行所需的CSV文件夹中的数据是完整的。

你可以将该文件拖到你打算使用的EmueraXXXX.exe中。

从1738g开始，当在分析模式下启用 "加载时显示报告 "时，将显示每个加载的ERB文件中的函数列表。

### 调试模式 Debug Mode

这是以`-Debug`作为命令行参数调用时的模式。 详见[调试模式]()。

## 窗口对话框 Window Dialogue

### 主窗口 Main Window

这是在启动时通常打开的第一个窗口。

### 主控制台 Main Console

这是主窗口中特别是进行输入和输出的部分的名称。

### 调试窗口 Debug Window

这是程序在调试模式下启动时可以打开的窗口。

### 调试控制台 Debug Console

这是调试窗口的一部分的名称，当你选择 "控制台 "选项卡时，它将进行输入和输出。

### 设置对话框 Config Dialogue

这是从主窗口的帮助、设置菜单中打开的对话框。

### 剪贴板对话框 Clipboard Dialogue

这是你从主控制台用`Ctrl+C`打开的对话框。

## 函数

### 命令 Command

包括Print和Wait。

### 函数 Function

这些函数的名称在ERB脚本的`@`语句中定义，并由`Call`指令或类似指令调用。

这包括**可在表达式中使用的函数**，其名称在`@`语句中定义。

### 事件函数 Event Function

一个名称以EVENT开头并被系统调用的函数。

如果你定义了一个以上的，它们都会被调用。

### 预处理器 Preprocessor

ERB文件夹中的一个文件中的一行，在任何其他指令之前被处理。

它是以`#`开头的一行，或以`[]`括起来的一个短语。

以`#`开头的行被划分为属性和定义。 更多信息见[那里]()。

用`[]`括起来的行是特殊块。

更多信息见[本页面]()。

### 属性（预处理器）Attribute (Preprocessor)

预处理器是以`#`开头的一行，它指定了一个函数并决定了该函数的规格和行为。

`#PRI`，`#LATER`，`#SINGLE`，`#ONLY`来控制事件函数执行时的行为。

`#FUNCTION`和`#FUNCTIONS`用于指定表达式中的函数类型。

### 定义（预处理器）Definition (Preprocessor)

以`#`开头的一行是一个预处理程序，它定义了变量的名称和它的规格。

`#LOCAL`，`#LOCALSIZE`，`#LOCALSSIZE`来指定变量中的元素数量。

变量，`#DIM`和`#DIMS`用于定义变量，`#DEFINE`用于定义ERH中的DEFINE宏。

### 可在表达式中使用的函数

这些是可以从表达式中调用的函数。

"功能 "不仅包括上述功能，还包括下面描述的内置功能。

在许多编程语言中，它们被简单地称为 "函数"。

### 式中函数

可在表达式中使用的函数的缩写。

它与编程语言中的匿名函数或内联函数没有关系。

### 内置函数 Built-in Function

表达式中的一个函数，最初是内置于Emuera中的，可以通过`@`语句在没有定义的情况下使用。

这些包括`Abs(X)`和`GetTime()`。

这很复杂，但它们并不对应于上述函数定义。

如果你把它们看作是“可用于表达的指令”，它们可能更容易理解。

### 用户自定义函数 User-defined Function

它是一个用户定义的函数。

它是一个函数，其名称由ERB脚本中的`@`语句定义，并由CALL指令或类似指令调用。

换句话说，与上述函数的概念相同。

### #Function(s)函数

一个函数，其名称由`@`语句定义，并且具有`#FUNCTION(S)`属性。

一个既是函数又是表达式中的函数的函数。

## 行、语句、表达式

### 行

它是指从一个换行代码到下一个换行代码的周期。

在编程中，这也被称为物理行。

在编辑器中，它通常被称为逻辑行。

### 语句

语句或逻辑行是Emuera中的一个处理单位。

大多数语句由一条指令和它的参数组成，或由一个变量、一个赋值运算符和一个表达式组成。

由于ERB中每行一句的铁律，行和句子的意思几乎一样。

维基没有对它们进行区分。

### 表达式

这些是变量、常数、表达式中的函数、非赋值运算符、括号和它们的组合。

赋值运算符只能作为赋值语句中的第一个运算符使用，不能在表达式中使用。

### 数字表达式

一个表达式，该表达式的评估结果（操作的结果）是一个数字。

例如，`A + B`，`STR == "Ayu"`，等等。

### 字符串表达式

一个表达式，该表达式的评估结果（操作的结果）是一个字符串。

例如，`STR + STR:1`，`"a" * 10`，等等。

## 变量

### 伪变量

像`Rand`和`CharaNum`一样，它可以被写成一个变量，但并不是一个真正的变量。

它的内部行为类似于表达式中的函数。

### 数组变量

一个有多个元素的变量。

数组变量的元素数可以在VariableSize.csv中改变，通常不会在脚本中增加或减少。

然而，对于某些局部变量，可以在脚本中指定数组元素的数量。

### 角色变量 Character Variable

一个变量，记录一个角色的状态。

它与C语言的char类型变量等没有关系。

由于其性质，元素的数量随着`AddChara`或`DelChara`角色的增加或减少而增加或减少。

在Eramaker的解释中，它被视为数组变量之一，因为它以与数组变量相同的形式指定元素，如`NO:TARGET`，但本wiki区分了字符变量和数组变量。

### 二维数组变量

一个既是字符变量又是数组变量的变量。

它需要两个参数（可选），如`CFLAG:TARGET:2`。

由于它是一个字符变量，第一个参数是字符编号。

随着字符的增加或减少，第一维中的元素数量也会增加或减少。

第二个维度的元素数量只能在VariableSize.csv中改变，不能在脚本中改变。



本文档不使用 "双数组 "一词，除了描述eramaker的规范。

相反，我们将使用 "字符变量和数组变量 "等术语。

### 多维数组变量

二维阵列变量，如`DItemType`，以及三维阵列变量，如`TA`。

它们可以接受两个或三个参数，如`DA:0:1`或`TA:1:2:3`。

多维数组变量的元素数只能在VariableSize.csv中改变，不能在脚本中增加或减少，而且多维数组变量的参数不能省略。

### 角色多维数组变量

一个既是角色变量又是多维数组变量的变量。

它需要三个参数（非可选），如`CFLAG:TARGET:0:2`。

由于它是一个角色变量，第一个参数代表角色编号。

随着角色数量的增加或减少，第一维度的元素数量也在增加或减少。

第二和第三维度的元素数量只能在VariableSize.csv中改变，不能在脚本中改变。



从ver1807开始，唯一适用于这个变量的是CDFLAG。

更多信息见[CDFLAG]()。

### 本地变量 Local Variable

这些是为每个函数（函数名）提供的变量，如LOCAL、LOCALS和私有变量。

私有变量将在另一节中描述。

至于`Local`和`Locals`以外的私有变量，其实不是所谓的局部变量，而是名为`LOCAL@函数名`或`LOCALS@函数名`的公共静态变量。

即使离开了函数，它们也会保留其价值，并且可以从函数外部分配或引用。

当函数被多次调用时，例如在递归调用中，该值也被共享。

### 广域变量 Nonlocal Variable

它是一个变量，其值被所有的函数共享，除了`Local`、`Locals`和私有变量外，大多数变量都属于这个变量。

它是一般编程语言中全局变量的概念。

你也可以通过使用`#DIM`或`#DIMS`在ERH中定义一个全局变量。

欲了解更多信息，请参考[头文件（ERH）]()页面。

### 全局变量 Global Variable

一个变量，其值可以在不同的保存数据之间共享。 全局变量也包括在广域变量中。

它们在保存加载和初始化的时间上与普通变量不同。

Emuera中的全局变量这与普通编程语言中的全局变量的概念无关。

### 私有变量 Private Variable

这些是由`#DIM`或`#DIMS`为每个函数（函数名称）定义的变量。

这些也是局部变量，所以它们对每个函数都是独立的。

然而，与同样被视为局部变量的`Local`不同，它们不能被分配到或从函数外部引用，例如使用`@函数名`。

更多信息请见[用户定义的变量]()页面。