# Emuera 中文文档

VERSION：0.1.0-191017

作者：Miswanting

**特别声明：全文大量地参考了`甜艮菜`大佬发布的相关教程，没有他的总结归纳、授权以及在文档编写与校对期间的鼎力协助，这篇文档断然无法顺利编写出来与大家见面。在此特别感谢！**

作者的话：本文档是基于EraLife项目开发需要，对Emuera解释器使用方法和EraBasic语法调研后的产物。由**EraBasic 语言参考**和**Emuera 使用说明**两部分构成。具有以下特征：

- 文档结构参考并优化自Python官方文档；
- 文档中**EraBasic 语言参考**部分有大量知识点是基于`甜艮菜`大佬的总结归纳；
  - 原始教程：TODO
- 文档中**Emuera 使用说明**部分来自作者对Emuera日文Wiki的总结归纳。

## 目录

[toc]

# EraBasic 语言参考

## 概述

## 使用Emuera解释器

## 内置类型

ERA中有两种数据类型。

### 逻辑值类型：bool

有时需要判断条件

那么就需要逻辑运算

首先应当了解

true 真

false 假

真 就是条件成立，假 就是条件不成立

ERA中 非0为真 也就是 只有 0 是假 其他的数字都是真

### 数字类型：int64

Era中只存在一种数字类型：int64

#### 基本运算

整型变量的计算方法与其他程序语言大同小异，来看看你是否能够无师自通。

我们来尝试依次做下列计算，然后核对一下答案，看看你对整型变量的计算方法是否真正掌握了：

- 赋值
  - A = 2
  - B = A
- 加法
  - C = A + 1
  - D = B + C
- 减法
  - E = A - 1
  - F = C - E
- 乘法
  - G = A * 2
  - H = B * C
- 除法
  - I = D / 3
  - J = D / A
- 取余
  - K = D % 3
  - L = D % A
- 乘除优先
  - M = A + B * C
- 括号优先
  - N = (A + B) * C
- 乘上小数
  - O = TIMES A, 1.6

> 答案：
>
> A == 2，B == 2，C == 3，D == 5，E == 1，F == 2，G == 4，H == 6，**I == 1，J == 2，**K == 2，L == 1，M == 8，N == 12，**O == 3；**

### 文本序列类型：string

Era中只存在一种文本序列类型：string

#### 基本运算

字符串型变量稍微麻烦一点，需要认识新的赋值运算符：`'=`

- 赋值
  - LOCALS '= RESULTS


> 考察两种不同的赋值语句
>
> 1. LOCALS '= RESULTS
>    - LOCALS 的值就将被赋值为RESULTS的值
> 2. LOCALS = RESULTS
>    - LOCALS 的值将为RESULTS
>
> 因为在字符串运算中`=`号右边的式子被称为`FORM文本式`；
> 请先记住 FORM文本式 ，详细内容之后介绍；请暂且理解为`文本`。
> 你写什么就是什么的文本
> 所以使用`=`的结果就是`=`后是什么，值就将是什么。
> 而使用`'=`就不一样，`'=`的右边，是字符串型，也就是只接受字符串型变量，如 RESULTS
> 如果不使用变量赋值，也可以自己填写新的内容
> LOCALS '= "新的内容"
> 那么 LOCALS 的值则为 新的内容
> LOCALS = "新的内容"
> 那么 LOCALS 的值则为 "新的内容"

- 连接
  - RESULTS '= "ABC" + "DEFG"
- 重复
  - RESULTS '= "ABC" * 5

## 内置常量

## 变量

变量可以看作储存数据的容器。

### 变量的类型

整型：只装有整数，如1，0，-1

字符串型：只装有字符串，如“甲”，“乙丙”

> 注意：ERA中不支持浮点数，也就是小数。

除法常会造成小数

小数将会被向下取整，如：1.1=>1，1.9=>1；

## 内置运算符

### 算数运算符

有变量就自然要计算

想要计算就得了解运算符

- 加法：\+
- 减法：\-
- 乘法：\*
- 除法：/
- 取余：%

### 比较运算符

请注意，逻辑运算中，括号内也是优先计算的

接下来了解逻辑运算符

\> 大于

< 小于

\>= 大于等于

<= 小于等于

== 等于

!= 不等于

1 > 1 为 假

1 > 0 为 真

1 >= 1 为 真

1 < 1 为 假

1 <= 1 为 真

1 < 0 为 假

 == 1 为 真

1 == 0 为 假

1 == 2 为 假

1 != 1 为 假

1 != 0 为 真

100 为 真

1 为 真

0 为 假

-1 为 真

-100 为 真

以上不仅可以判断数字 也可以 判断字符串

如

"A" == "A" 为真

LOCALS == "" LOCALS是否是空字符串，是空字符串则为 真

LOCALS == "A" LOCALS是否是 A 是 A 则为 真

但请不要用 大于小于 来判断字符串 好奇的话可以试试

### 赋值运算符

- 赋值：=
  - 赋值运算符的左边必须是`变量`，其他的运算符左右可以是常数也可以是变量

现在，可以学习新的赋值运算符了

+=

*=

/=

%=

都是什么意思呢？

LOCAL += 1 等于 LOCAL = LOCAL + 1

LOCAL -= 1 等于 LOCAL = LOCAL - 1

LOCAL *= 2 等于 LOCAL = LOCAL * 2

LOCAL /= 2 等于 LOCAL = LOCAL / 2

LOCAL %= 2 等于 LOCAL = LOCAL % 2

LOCALS '= "b"

LOCALS += "aa" 等于 LOCALS '= LOCALS + "aa" 等于 LOCALS '= "b" + "aa"

字符串型也可以使用 *= 但必须是乘数字，至于其他的运算就不行了

就是这样

为了方便

### 自增减运算符

LOCAL++ 等于 LOCAL += 1

LOCAL-- 等于 LOCAL -= 1

++LOCAL 等于 LOCAL += 1

--LOCAL 等于 LOCAL -= 1

咋看是一样的啊？

加号和减号在前面和在后面有什么区别呢？

在后面则是 先引用变量后改变变量

在前面则是 先改变变量后引用变量

不理解没关系

通常的使用是

LOCAL++

LOCAL--

就是方便地让 LOCAL 加一减一罢了

### 逻辑运算符

接下来了解更多的运算符

! 逻辑非

&& 逻辑与

|| 逻辑或

^^ 逻辑异或

!& 逻辑与非

!| 逻辑或非

! 的意思是取反

!真 的结果就是 假

!假 的结果就是 真

常用于判断 条件不成立时成立

如 !今天下雨了

实际上今天没下雨

那么 这个条件就成立了，反之不成立

&&、|| 的用法更简单

&& 全真则真 有假则假

真 && 真 为 真

假 && 真 为 假

真 && 假 为 假

假 && 假 为 假

|| 有真则真 全假则假

真 || 真 为 真

假 || 真 为 真

真 || 假 为 真

假 || 假 为 假

^^、!&、!| 稍微麻烦一些

^^ 全真则假 全假则假 不同则真

真 ^^ 真 为 假

假 ^^ 真 为 真

真 ^^ 假 为 真

假 ^^ 假 为 假

!& 有假则真 全真则假

真 !& 真 为 假

假 !& 真 为 真

真 !& 假 为 真

假 !& 假 为 真

!| 有真则假 全假则真

真 !| 真 为 假

假 !| 真 为 假

真 !| 假 为 假

假 !| 假 为 真

### 三元运算符

?

\#

这就是三元运算符

三元运算的结构

逻辑运算 ? 逻辑运算为真的结果 # 逻辑运算为假的结果

例子如下

A == 1 ? 2 # 0

这一句的意思就是

如果 A 等于 1 那么返回的结果就是 2 ，否则是 0

这通常要用 IF 语句才能做到，但是有了三元运算符，这将十分简短

三元运算符的应用

B = A == 1 ? 2 # 0

一般就是这么用的

除了返回整型

还可以返回字符串型

\@A == 1 ?字符A#字符B\@

返回字符串型的三元运算需要用 \@ 围起来

? 和 # 后的文本是 FORM文本式

FORM文本式将在之后讲解

三元运算的嵌套

A == 1 ?(B == 1 ? 2 #(C == 2 ? 7 # 10))# 0

就是这样，只要用括号围起来就好了 

## 内置函数

### 存档读档

有预先编写好的系统指令可以直接调用

SAVEGAME

LOADGAME

大家用一用就知道是个什么东西了

很方便

自己写个新的，画面表现更好的存档界面也是可以的

## 内置异常

## 流程控制

### IF 语句

之前超基础的东西讲完了，时候运用了

首先需要注意的是 ERA 所有 指令 包括内置的 变量 都必须使用大写字母书写

首先是IF语句

IF语句的基础结构是

IF 逻辑运算

ENDIF

拓展结构是

IF 逻辑运算

ELSE

ENDIF

IF 逻辑运算

ELSEIF 逻辑运算

ELSE

ENDIF

其中 ELSEIF 和 ELSE 都可以随意省略

ELSEIF 可以有无数个 但是 IF 和 ELSE 和 ENDIF 只能有一个

那么 IF 语句该如何使用呢？

当 IF 后的逻辑运算为真时就会执行 IF 下的语句

IF 真

​    A = 1

ENDIF

这个的结果当然就是 IF 为真

于是 开始执行 IF 下的语句 A = 1

如果为假就会直接跳到 ENDIF 处， IF 语句就此结束

IF 假

​    A = 1

ELSEIF 真

​    B = 1

ENDIF

现在 IF 为 假了，当然是要跳到 ENDIF 了吧

啊？结果不是这样吗？

当然不是

现在有了 ELSEIF

且 ELSEIF 的结果 为真

于是会执行 ELSEIF 下的语句 ， B = 1

执行完后将会跳往 ENDIF

IF 假

​    A = 1

ELSEIF 假

​    B = 1

ELSEIF 真

​    C = 1

ENDIF

有多个 ELSEIF 呢？

依次执行

遇到为真的 ELSEIF 则执行其下的语句，执行完后不会跳往下一个 ELSEIF 或者 ELSE 而是直接跳往 ENDIF

那么 ELSE 又有什么用呢？

ELSE 是用于 IF 、 ELSEIF 都为假的情况下使用的

IF 假

​    A = 1

ELSEIF 假

​    B = 1

ELSEIF 假

​    C = 1

ELSE

​    D = 1

ENDIF

在这个情况下 IF ELSEIF 都为假了，就会跳转到 ELSE 执行其下的语句 D = 1

然后跳转至 ENDIF ， IF 语句结束

在 IF 中是可以嵌套 IF 的

IF 假

​    IF 真

​        IF 真

        ENDIF
    ELSEIF 假
        
    ELSE
        IF 真
        
        ENDIF
    ENDIF

ELSEIF 假
    B = 1
ELSEIF 假
    C = 1
ELSE
    IF 真
    

    ENDIF

ENDIF

可以随意得套用

但请注意 IF 与 ENDIF 的对应关系 如果有缺少 ENDIF 就会报错

SIF 语句

这条语句是为了结果只有一条语句的情况下使用的，就是为了方便

SIF 真

​    A = 1

SIF 的值为 真

则会执行下一行 A = 1

如果为 假 则跳过下一行

SIF 不能嵌套 SIF ,也不能嵌套 IF 和其他的 分支语句

但是其他的分支语句可以嵌套 SIF

需要注意的是，在逻辑运算中，前面的运算判定为 假 ，而后面的运算不可能逆转为真时，后面的运算就不会被执行了

如

A = 0

B = 1

A == 1 && B == 1

因为 A == 1 为假

所以 b == 1 就不会被计算了

这通常会用于某些变量的值为某些数，如 负数 时，会报错的情况下，在之前给一个检测这个变量是否是正数，为负数那么后面的就不会执行了，也就避免报错了

IF 也有一个预处理指令

[IF_DEBUG]

​    这里面的只在DEBUG模式启动时会被读取

[ENDIF]

### SELECTCASE语句

这是非常方便的分支语句，用于对一个变量的大量条件判断

SELECTCASE 变量

​    CASE 判断的值        

    CASEELSE

ENDSELECT

其中的 变量 是填需要判断的变量，可以是数字可以是字符串

判断的值，就是检测 变量的值 是否等于 判断值

如果变量时 数字 ，判断值就要是数字，如果是 字符串 ，判断值就要是字符串

CASEELSE 就是 CASE 全都判断为 假 时执行

CASEELSE 可以省略， CASE 不能省略

SELECTCASE 与 IF 一样可以嵌套，也可以在 SELECTCASE 中嵌套 IF 等语句

接下来是举例

LOCALS '= "ABC"

SELECTCASE LOCALS

​    CASE "ABC","什么破教程","连PRINT都不先讲"

​        A = 1

​    CASE "不讲PRINT还做个捷报"

​        B = 1

​    CASE "丢人！"

​        C = 1

​    CASEELSE

​        D = 1

ENDSELECT

已知 LOCALS 的值为 ABC 了

那么哪一个小 CASE 那么幸运，会被我抓去煲汤呢？

恭喜你了，拿着 A = 1 的小 CASE

那么这个小 CASE 上有很多个字符串 每个字符串都有逗号相隔

是什么意思呢？

意思就是 "ABC" || "什么破教程" || "连PRINT都不先讲"

只要有一个符合条件就为 真

当有一个 CASE 判定为真了 就会执行这个 CASE 下的语句 然后跳转到 ENDSELECT 结束语句
如果所有 CASE 都为 假 呢？

自然就是跳到 CASEELSE 了

之前说了 CASEELSE 可以省略，所以在省略 CASEELSE 的情况下 将会直接跳转到 ENDSELECT
在 CASE 中还有别的特别运算形式

TO

IS

TO 用于数字变量的判断

CASE 1 TO 5 等值于 CASE 1,2,3,4,5

IS 是代表变量的值

CASE IS == 1 || IS == 2 等值于 CASE 1,2

### FOR 语句

循环语句就是满足条件，就再次执行语句

FOR 循环的结构

FOR LOCAL,0,5

​    PRINTL 啊啊啊啊啊

NEXT

FOR 循环需要使用两个逗号，分隔三个参数

第一参数是循环内将要用到的整型变量

可以是任何已经声明的整型变量

这里使用LOCAL

第二参数是变量的初始值

在循环开始时，变量将会被赋值为这个初始值

第三参数是变量的最大值

当变量等于这个最大值的时候，就会停止循环

FOR 循环内的那个 PRINTL

就是把内容输出到画面的语句了

PRINTL 啊啊啊啊啊

被执行后 你就可以在画面上看到 啊啊啊啊啊

那么这个 FOR 循环的结果是什么呢？

啊啊啊啊啊

啊啊啊啊啊

啊啊啊啊啊

啊啊啊啊啊

啊啊啊啊啊

就是五行整整齐齐的 啊啊啊啊啊

为什么呢？

当 FOR 循环开始时

LOCAL = 0

IF LOCAL < 5

​    PRINTL 啊啊啊啊啊

​    LOCAL++

​    回到 IF 重新判断

ELSE

​    跳至 NEXT 结束 FOR 循环

ENDIF

就是这么个原理

看不懂就翻回上面再复习！

FOR 循环中可以嵌套其他任意的语句，但是如果改变 FOR 循环所使用的变量的话，会变得很麻烦，所以请尽量不要改变

### WHILE 语句

WHILE 循环的结构

WHILE LOCAL < 5

WEND

WHILE 循环看起来就很简单了

只有一个逻辑运算 这个运算 为真则循环，为假 则跳出

也不会对改变变量，单纯只是判断而已

其运行模式是这样的

IF LOCAL < 5

​    回到 IF 重新判断

ELSE

​    跳至 WEND 结束 WHILE 循环

ENDIF

WHILE 循环同样可以嵌套任意的语句，但是改变逻辑运算中的变量一样会变得很麻烦，请按需使用

### GOTO 语句

$标签

GOTO 标签

标签有个前缀

$

在这个符号后的字符将会被设置为标签

GOTO 标签

则会跳转到标签所在位置

注意不要死循环了

如果跳转到 IF 语句中，则会执行完当前程序块，然后跳转至 ENDIF

跳转到 CASE 中也是一样

FOR 中 WHILE 中也都是一样的，并不会开始循环，而是只执行一次

GOTO 只能在当前函数内跳转，不能跳到函数外

BREAK

在循环中常用的指令，意思是立即跳出当前循环，就是直接结束循环了

CONTINUE

在循环中常用的指令，意思是立即开始下一次循环，并不会直接结束循环

## 数据结构

### 数组

数组是什么？

就是数组啦~

哈哈哈哈！

在ERA中，数组的书写形式是

A:0 一维数组

A:0:0 二维数组

A:0:0:0 三维数组

: 号就是分隔符

0 就是数组 索引值，必须是整型

索引值是可以计算出来的，也可以使用变量

A:B:(C+1):LOCAL

可以这样写，有计算如 C+1 必须加括号

可以说 所有变量都是 一维数组

其正规书写形式是 A:0

简写可以是 A

多维数组不能简写

索引值为负数或者超过数组长度就会报错

接下来是数组的重要知识

(1)
ERA中有角色数组和一般数组

角色数组如

CFLAG:0:0

角色数组第一参数是可以省略的

也就是可以写成 CFLAG:0

其会被读取为 CFLAG:TARGET:0

被省略的第一参数会被填补成为 TARGET 这个变量

(2)

在CSV文件中，常会定义数组的标签

如

BASE:体力

这个体力就是标签

体力 根据CSV中的序号，会是相应的值

但有一种情况，会使标签失效

\#DIM 体力

就是这样，如果有自定义的变量名跟标签重名的话，就会优先使用变量的值

\#DIM 体力 = 2

PRINTVW BASE:体力

如果 体力 的序号是 0 那么现在显示的将不是序号为 0 的 体力 的值，而是序号为 2 的变量的值了
(3)

不！——知！——道！！！——————————哈哈！！

## 输入与输出

### 输出文本

终于到了可以见到实质结果的地方了

是不是已经弃坑了呢？

没有关系

从入门到入土就是这么简单

PRINT 系指令

PRINT

PRINTS

PRINTV

PRINTFORM

这四种有什么区别呢？

PRINT 的后面无论写什么，都是会直接打印到屏幕上的

PRINTS 后面要写字符串变量，会读取变量的值打印到屏幕上

PRINTV 跟 PRINTS 一样，不过是打印整型变量

PRINTFORM 是采用 FORM文本式 打印的指令

> ### FORM 表达式
>
> FOMR文本式临时大补课！
>
> 这个文本式 平常是这样的
>
> LOCALS = 巴拉巴拉巴拉
>
> 注意使用的赋值运算符是 = 而不是 '=
>
> 那么LOCALS 的值为 巴拉巴拉巴拉
>
> 字符串型变量A '= "强啊！"
>
> 整型变量A = 100
>
> LOCALS = 巴拉%字符串型变量A%巴拉{整型变量A}巴拉
>
> 这样的话
>
> 结果是什么呢？
>
> 巴拉强啊！巴拉100巴拉
>
> 就是这个了！
>
> 在 FORM文本式 中，用%%圈起来的是字符串变量，用{}圈起来的是整型变量
>
> 就是这样！
>
> 但里面还能有其他的参数
>
> %"哈",3%
>
> 这样的话结果就是|哈 |
>
> 注意到 哈 和 | 中的空格了吗？
>
> 里面的参数 3 就是用于对齐的，默认是左对齐，数字是指半角字符数，字符串比数字小，多余的就会被空格填充，前面说到的{}也是一样的可以这么使用
>
> %"哈",3,RIGHT%
>
> 看到第三参数了吗？右对齐的意思，如果是 LEFT 就是左对齐，然而并没有 CENTER 可以用，死心吧

那么懂了 PRINT 的基础形式

接下来该怎么办呢？

那么就是变体了

PRINTL

PRINTSL

PRINTVL

PRINTFORML

有什么不同？后面都加了 L 对吧

这个是换行的意思

不加 L 的话

PRINT 啊

PRINT 啊

的输出结果就是

啊啊

加了 L 的输出结果就是

啊

啊

明白了吗？

下一个变体

PRINTW

PRINTSW

PRINTVW

PRINTFORMW

L 被换成了 W

W 是代表一个指令 WAIT

就是等待，必须要有鼠标点击或者输入字符才会结束等待

所以

PRINTW 等待中

PRINTL 等待结束

屏幕上会显示等待中，然后就不动了，当你按下鼠标，就会显示 等待结束

PRINTW 是会换行的

下一个变体

PRINTC

PRINTSC

PRINTVC

PRINTFORMC

那么加了 C 的又是什么呢？

就是自动对齐了

对齐的补充值在设置中调整

默认是右对齐

如果写成

PRINTLC 则是左对齐

### 输出按钮

会输出文本了，那么怎么输出按钮呢？

PRINT [0]按钮0

这样就可以了 在[]中的数字会被当作按钮，让它周围的文本都变成可以按的按钮，直到下一个[]按钮出现或者换行

而按钮的结果也就是[]中的数字

但是仅仅如此还是不够的，必须要有能接收按钮返回值的指令

INPUT

这样就会进入等待

按下按钮之后就会执行 INPUT 之后的语句

同时，一个内置整型变量 RESULT 会发生改变

它的值会变成按钮返回的值

按钮[]中的数字是0 RESULT 会变成0，是1就会变成1

按钮中也可以是负数

出了这种方法，还有另一种方法

PRINTBUTTON

就是这个了！

PRINTBUTTON "字符串",0

第一参数是按钮文本

第二参数是按钮反馈的值

使用这个指令也可以做出返回字符串值的按钮

PRINTBUTTON "字符串","返回字符串值"

但是这样必须要用

INPUTS

来接收字符串型的返回值

这样的话，被复制的变量也不是整型的 RESULT 了

而是字符串型的

RESULTS

那么如果想在 PRINTBUTTON 中引用变量怎么办？

PRINTBUTTON "字符串"+字符串变量,0

但是这样只适用于字符串变量

这时候就需要 @ 这个符号了！

PRINTBUTTON @"字符串%字符串变量%{整型变量}",0

这样就可以将字符串中的文本转换为 FORM文本式 然后读取了

PRINTBUTTON 是不会换行的，请手动换行

按钮的使用就到这里了

但是会做按钮还不够，按钮得有用处

通常在 INPUT 后会接 IF 等语句来判断接下来要执行的语句

PRINTL [1] - 前进！

PRINTL [0] - 怂了！！

INPUT

IF RESULT == 0

​    啊啊！

ELSEIF RESULT == 1

​    死亡！

ENDIF

就是这样嘿！ 

### 输入

## 函数与方法

非常基础的东西已经讲了很多了，但光知道这些是没办法让ERA读取的

你非常需要含树…不！我是说函数……

### 函数的定义

函数如何定义

@

在一行的首字符前加一个 @

就完成了函数的声明

函数名不能以数字开头，不能重名，不能是变量名，不能与指令重名

@新的函数

PRINTL 在这个函数下就可以随便写了

PRINTW 想写什么都可以

PRINT 只要符合语法规范

PRINTW 就没有问题！



### 函数的参数

@新的函数(ARG,ARGS)

在声明新的函数时，可以在后面加括号，里面写上参数

这样的话，就可以传值了

#### 传值与传参

##### 传值

值传递是什么意思呢？

CALL 新的函数(1,"ABC")

现在调用了刚才声明的函数

于是刚才声明的函数中写上的参数

ARG 的值就为 1 了

ARGS 的值就为 ABC 了

参数是不能省略的

如果要省略该怎么办呢？

@新的函数(ARG,ARGS = "ABC")

就在声明参数的时候，给初始值

这样的话，如果在调用时，省略了这个参数，那么这个参数就会是初始值，没有省略，则会被赋值

看到这里大家一定还有个问题

ARG 和 ARGS 是什么？

它们是函数专用的变量，必须在参数中声明才可以使用

它们是一维数组

所以具有 ARG:0,ARG:1,ARG:2 等形态可以使用

其中 ARG:0 等同于 ARG

ARGS 也是一样的

顺便一说

LOCAL LOCALS RESULT RESULTS A B C 等等，内置变量，全都是一维数组

关于数组，会在之后提到

在这里还要特别说明 LOCAL LOCALS

这两个变量是函数专属的，也就是在 A函数 中 LOCAL 为 1 了

但是在 B函数 中 LOCAL 还是 0

在不同的函数中， LOCAL 是无法互相改变的，因为 LOCAL 是函数私有的，每个函数都有单独的 LOCAL

现在

大家已经懂了很多了

但是还不不够！

还要学习如何声明 函数私有变量

@新的函数(私有变量A,私有变量B)

\#DIM 私有变量A

\#DIMS 私有变量B

就是这样

变量必须在函数的开头声明

\#DIM 是声明整型变量

\#DIMS 是声明字符串型变量

自定义的变量可以在参数中使用

变量名不能以数字开头，不能是已经存在的变量的名字（与其他函数的私有变量重名没有关系），不能是指令名

在声明的变量后可以给初始值

\#DIM 变量A = 1

这样 变量A 的初始值就是 1 了

但是，这并不是每次调用函数都会把 变量A 的值设为 1

变量默认是 静态 的

只有一次初始化

这代表着下次调用函数，它的值该是什么还是什么

如果想让变量每次被调用都会初始化该怎么办呢？

\#DIM DYNAMIC 变量A = 1

就是这样

同时还有不能改变值的常量

\#DIM CONST 常量A = 1

这是声明常量，常量必须有初始化的值，也不能再更改

如何声明数组？

\#DIM 数组,10

这是声明有 10 个元素的一维数组

\#DIM 数组,10,10

这是声明有 10\*10 个元素的二维数组

\#DIM 数组,10,10,10

这是声明有 10\*10\*10 个元素的三维数组

有四维数组吗？

没有

##### 传参

引用传递是什么？

@函数A

\#DIM 整型变量A

CALL 函数B(整型变量A)

@函数B(整型变量B)

\#DIM REF 整型变量B

现在，可以看到 #DIM 后 有一个 REF

这就是引用传递的标识

在 函数B 中改变了 整型变量B ，那么 函数A 中的 整型变量A 也会发生改变

在调用函数的参数中，放在 REF 变量的位置的变量 必须是变量，而不能是常量

如果要引用的是数组该怎么办？

\#DIM REF 整型变量B,0

这是一维数组 可以省略 ,0

\#DIM REF 整型变量B,0,0

\#DIM REF 整型变量B,0,0,0

数组的长度要设为 0 ，接下来该怎么用就怎么用

### 函数的结束与返回

函数的结束是有标准指令的

RETURN

执行这个指令的话，就会直接结束当前函数

其会有一个默认的返回值 0

然后 RESULT 变量就会变成返回值

RETURN 0

RETURN 1

这样指定返回值 RESULT 会有相应的改变

RETURN 0,20,37

也可以指定多个返回值，这样的话会一次对应 RESULT 数组

RESULT:0 == 0

RESULT:1 == 20

RESULT:2 == 37

返回值也可以是字符串型

RETURN "ABC"

会存入 RESULTS

同样可以返回数组

整型和字符串型无法同时返回

不写 RETURN 的话

在函数的最末位默认就是 RETURN

RESTART

重新开始函数，就是返回函数开头

但是这个指令并不会导致自定义变量被初始化

请注意使用，避免死循环

### 函数的调用

如何调用函数？

@新的函数B

@新的函数A

CALL 新的函数B

这样就在 新的函数A 中调用 新的函数B 了

CALL 语句，就是用来调用函数的

如果函数不存在的话就会报错

因此有变体如下

TRYCALL 尝试调用，函数不存在就什么也不做

CALL 指令还有别的变体

CALLFORM 函数名可以用 FORM文本式 来指定

TRYCALLFORM TRY 尝试调用

TRYCCALL

​    函数存在时，在执行完函数之后会执行这里的语句

CATCH

​    函数不存在会执行这里的语句

ENDCATCH

发现了吗？多了一个C,就是如上的解释了，同样有 TRYCCALLFORM

### 方法（式中函数）

@方法A

\#FUNCTION

RETURNF 0

在函数的第一行写上

\#FUNCTION

就声明了一个方法

方法的结束不是 RETURN 而是 RETURNF ,不要用错

方法的返回值只有一个，不能返回数组

;返回类型

如果第一行写的是 #FUNCTION 则返回类型是整型，如果写的是 #FUNCTIONS 则返回类型是字符串型

方法该如何使用呢？

方法常用于条件判断中

@今天下雨了

\#FUNCTION

RETURNF 1

@MAIN

IF 今天下雨了() == 1

​    PRINTL 今天下雨了

ENDIF

在使用方法时，在方法名后加上括号，来区分变量与方法

然后判断方法返回的值

上面声明的方法中 RETURNF 1 所以返回值是 1

那么条件成立

在屏幕上打印了 今天下雨了

函数也是与函数一样可以有参数的,声明方法、使用方法也是一样的，而且方法的参数比函数的参数要重要得多

@今天下雨了(星期几)

\#FUNCTION

\#DIMS 星期几

SELECTCASE 星期几

​    CASE "星期一"

​        RETURNF 1

​    CASE "星期二"

​        RETURNF 0

​    CASE "星期三"

​        RETURNF 1

​    CASE "星期四"

​        RETURNF 0

​    CASE "星期五"

​        RETURNF 1

   CASE "星期六"

​        RETURNF 0

​    CASE "星期日"

​        RETURNF 1

ENDSELECT

RETURNF 0

@MAIN

IF 今天下雨了("星期一") == 1

​    PRINTL 今天下雨了

ELSE

​    PRINTL 今天没下雨

ENDIF

看懂了吗？

没有看懂就去复习吧！

方法可以在任何一个变量能出现的地方出现

PRINTFORM %字符串变量A%哇%字符串方法()%！

这样的话，在字符串方法的位置，就会打印出这个方法返回的字符串 

## 书写规范

编写代码请规范书写

A = 1 + 1

看到了吗？嫦娥？

……

不不不，是看到了吗？每个符号间都有空格

这就是书写规范

IF 真

​    IF 真

​        A = 1 + 1

​    ENDIF

ENDIF

看到了吗？

语句嵌套一定要写制表符在前面

制表符就是按 TAB 键之后写出的很长的空格

# Emuera 使用说明

## 概述

Emuera是Eramaker的重写版本，延续了Eramaker时代的eramaker basic（ERB）语法和启动流程，并在其基础上进行了扩展。

## 

## 文件类型

### ERH文件

ERH文件是用来声明自定义广域变量的

;一般的静态变量，可以给初始值也可以不给

\#DIM 变量 = 0

;常量

\#DIM CONST 常量 = 0

;会被存档保存的静态变量，一半的静态变量是不会被保存的，可以给初始值也可以不给

\#DIM SAVEDATA 可以存档的变量

;可以存入GLOBAL存档的变量

\#DIM GLOBAL 存入GLOBAL存档的变量

声明数组的话与之前的函数声明数组是一样的

\#DIM 一维数组,10

\#DIM 二维数组,10,10

\#DIM 三维数组,10,10,10

可以给一维数组设定初始值

\#DIM 一维数组 = 1,2,35,7,89,45

\#DIMS 一维数组 = "a","awg","165","好强啊！"

设定的数量就是数组的长度

括号可以这样用，在括号里的就会被认为是一句

{

\#DIMS 一维数组 = "jtyj"

,"wga"

,"drjdryk"

,"rtjrtj"

}

#### 宏

不是很想讲宏

因为我很少用

宏也不复杂

\#DEFINE 一个宏 5

\#DEFINE 二个宏 "字符串"

\#DEFINE 麻烦的宏 5 + 5

\#DEFINE 超级麻烦的宏 麻烦的宏 + 麻烦的宏

A = 一个宏 展开为 A = 5

LOCALS '= 二个宏 展开为 LOCALS '= "字符串"

A = 麻烦的宏 展开为 A = 5 + 5

A = 超级麻烦的宏 展开为 A = 麻烦的宏 + 麻烦的宏 展开为 A = 5 + 5 + 5 + 5

宏的概念就是这样了

在应用中熟练吧，不用的话也不需要看更多细节了

最后，请注意ERH文件的读取顺序

### CSV文件

CSV文件很简单，可以去任何ERA游戏中复制，然后在里面改数据，非常简单，不需要教的
还是教一教吧……

如

#### BASE.CSV

0,体力

1,气力

……

……

……

第一个数字就是编号，第二个字符串就是标签

BASE:角色编号:体力 将会索引到 0

就是这样

有个特例

#### ITEM.CSV

0,标签,价格

有个没有标签

#### STR.CSV

0,字符串

STR的字符串就是这个序号的值了

因此没有

STR:字符串 这种用法

只能 STR:0

#### _Rename.CSV

这个不好用

太久没用

都忘了

大致是

变量,标签

TALENT:10,麻烦

使用的时候

[麻烦] 就是 TALENT:10 了

#### _Replace.CSV

很多初始化的东西

自己看着调

起動時簡略表示 , 少女折寿中……

这个比较重要，载入的时候显示的文字

#### GameBase.CSV

里面主要写 作品名 版本 制作年 作者 注释 之类的东西 如果自己写函数入口的话，有一些是没有用的，但是版本 作品名还是有用的 ，还可以设置存档版本，不同版本存档会被禁止使用

#### VariableSize.CSV

这个是很重要的文件，里面初始化了系统默认变量的长度

按需设置，节省内存

有一些CSV有很多连带的变量名

如BASE

就有

BASE

DOWNBASE

MAXBASE

BASENAME

Chara.CSV

角色数据文件

创建角色的时候就是调用这里的文件

里面可以设置各种角色变量的初始化

PALAM.CSV和JUEL.CSV有连带关系

两者的序号和标签要一样，不然会有很麻烦的事情

更多的就需要各位自己使用，自己总结经验，因为都是写细小砸碎的东西，要写出来很麻烦很麻烦，还写不全

#### CSV文件变量的使用和概念

CSV文件所表示的变量有些是角色变量，有些不是

如 BASE、TALENT、CFLAG、CSTR 等就是角色变量，都是可以省略第一参数的

那么这些变量都有什么用呢？

可以做任何用

变量是没有固定的用法的，请一定牢记在心

你可以用 CFLAG 来填素质，也可以用 TALENT 来填体力

因为它们只是 一个数值，关键是你怎么用它们

而它们的名称告诉了你，怎么用最好，所以 CLFAG 是用来给人物 插旗（雾）的，TALENT 是表示人物的素质的

BASE 则是表示一些基础属性的

他们还有一些连带的变量名

几乎每一个变量都有一个 NAME 变量

CFLAGNAME:序号

BASENAME:序号

TALENTNAME:序号

……

……

这些变量返回的是后接序号的标签名

还有一些很重要的

NAME:角色编号

CALLNAME:角色编号

就是人物的全名和昵称

但是有一些让你无法这么自由地使用

如 TFLAG,TEQUIP

这玩意的数值会在进入 BEGIN TRAIN 流程时被重置为 0

而流程是什么？请向后阅览 

## ERA游戏结构和流程

要写ERA游戏的话就要清楚其结构和流程，虽然可以自己写一个函数流程，不过了解流程，还是比较重要的，

在游戏最初会有一个函数入口

@SYSTEM_TITLE

这个函数如果没有自己编写的话

就会使用系统默认的

接下来是例子

@SYSTEM_TITLE

ALIGNMENT CENTER

DRAWLINEFORM -- - -- - - -

DRAWLINEFORM ♩♪♫♬♫♪♩✙

DRAWLINEFORM - - - - - -

SETCOLOR 青色

PRINT ♂

RESETCOLOR

PRINT era红魔馆NTR++

SETCOLOR 品红色

PRINTL ♀

RESETCOLOR

PRINTL 版本:0.010

PRINTL 制作人：甜艮菜

PRINTL 制作时间：ⓒ 2018年4月15日 - 2018年

PRINTL

PRINT ※这是以era紅魔館protoNTR和eraTW以及其他可能存在但没能列出的作品为参考的作品

DRAWLINEFORM -- - -- - - -

DRAWLINEFORM - - - - - -

PRINTL [0] 新游戏

PRINTL [1] 旧存档

INPUT

IF RESULT == 0

​    BEGIN FIRST

ELSEIF RESULT == 1

​    ALIGNMENT LEFT

​    LOADGAME

​    RESTART

ELSE

​    RESTART

ENDIF

直接拿自己的代码做例子了

ALIGNMENT 是指对齐方式 CENTER 就是居中，之后打印的所有文本都会以居中的方式显示，除此之外还有 LEFT、RIGHT

DRAWLINEFORM 会循环后面填的字符，画一行线，因此还有原版指令 DRAWLINE ，是用 - 画一条线

SETCOLOR 设置接下来打印的文字的颜色，参数是 十六进制颜色码 0xFFFFFF ，例子中我使用的是 青色 ，系统中并没有这个变量，这是在 ERH文件 中声明好的

选择 旧存档就会改变对齐方式为左对齐然后进入 LOADGAME ，如果没有读取存档就会执行 RESTART

补充一个指令

字体变粗体

FONTBOLD

字体复原

FONTREGULAR

同样还有变斜体，请上储备库查阅

选择新游戏，就会使用流程控制语句 进入新的流程

### BEGIN 流程控制语句

BEGIN 是用来跳转流程的，并且有其规则，在规则之外跳转是会报错的

正常流程如下

;进入 EVENTFIRST 函数

BEGIN FIRST

EVENTFIRST 函数主要用来初始化，如新建角色等

接着在 EVENTFIRST 的末尾

;进入 SHOW_SHOP 函数 如果读取了存档也会进入 SHOP 流程

BEGIN SHOP

SHOW_SHOP 是商店页面，系统默认会在这里利用ITEM.CSV的数据来买东西，所以叫商店页面，但是在这里你可以跟系统反着来，你可以随便编写你想要的界面

如 eraTW 中，一开始的能调选项的那个的界面就是 SHOW_SHOP 函数绘制的

在这个函数中常常会用来初始化、改变选项、查看信息等

在 SHOW_SHOP 的末尾 需要绘制按钮

如

PRINTL [100] - 睁眼

为什么呢？

因为在 SHOW_SHOP 结束后会跳转至 USERSHOP 函数

这个函数自带一个 INPUT

所以会在这个函数中写 按钮的结果

IF RESULT == 100

​    BEGIN TRAIN

ENDIF

重点来了

### 进入 SHOW_STATUS 函数 调教流程

BEGIN TRAIN

在 eraTW 中 你平时活动的界面就是由 SHOW_STATUS 绘制的 ，在 魔王 等作品中，调教的界面就是由 SHOW_STATUS 绘制的

在 SHOW_STATUS 结束后会跳转至 SHOW_USERCOM 函数

在这个函数中，系统会自动绘制 COM 选项，也就是在 TRAIN.CSV 中设定的选项

这个绘制流程会经过 COM_ABLE{TRAIN编号} 函数 这个函数的返回值将会决定选项是否会被绘制，返回值为 0 不会被绘制，为 1 会被绘制

你也可以自己写一个绘制流程， eraTW 便是自己编写的绘制流程

当 SHOW_USERCOM 函数结束后会跳转至 USERCOM 函数，这个函数跟 USERSHOP 函数一样自带一个 INPUT

选项的结果将在这个函数中被判断和执行

执行的函数会是 COM{TRAIN编号} ！此处存疑，因为我长期使用自己编写的流程，所以已经忘记这部分细节的系统流程是什么样的了

也许是 CALL COM{TRAIN编号}，也许是 DOTRAIN TRAIN编号，也许根本没有调用

结束后将会返回 SHOW_STATUS 函数，进行循环操作，直到跳转至其他的流程

需要了解的是

使用 DOTRAIN 指令执行调教指令首先会初始化UP、DOWN等变量，代入 SELECTCOM 的参数（ SELECTCOM 的参数就是选择的TRAIN编号）

跳转至 EVENTCOM 函数，执行完后跳转至 COM{TRAIN编号} 函数，执行完后跳转至 

SOURCE_CHECK 函数，执行完后跳转至 EVENTCOMEND 函数，执行完后返回 SHOW_STATUS 函数

红魔馆protoNTR 就是采用的这种方式，但略有修改

我则采用了另一种方式，也就是自己写入 SELECTCOM 参数， 手动 CALL SOURCE_CHECK 函数的方式

而 SOURCE_CHECK 常用于结算选项的结果 比如好感度上升了多少啊，经验上升了多少之类的，还有口上的显示等等

返回 SHOW_STATUS 函数之后 CUP、DOWNBASE 等变量都会被自动初始化为0 ，如果 SOURCE 变量没有被自动重置为 0 ，是推荐手动写一个函数重置为 0 的

除非你要留着 SOURCE 变量另作他用

有一些选项自然会用来进入下一个流程，一般就是 休息、睡觉 等

;进入 EVENTEND 函数

BEGIN AFTERTRAIN

EVENTEND 函数一般是用于结算的函数，但是也可以写任何想写的东西

;进入 SHOW_JUEL 函数

在末尾 BEGIN ABLUP

SHOW_JUEL 函数是用来显示 珠 的函数，看函数名就知道了，但是你也可以不在这里显示 珠 ，但通常还是用来处理 珠 的数据

SHOW_JUEL 函数结束后会跳转至 SHOW_ABLUP_SELECT 函数，这个函数起初是用来选择提升哪项能力的，如 魔王 ，然而 eraTW 和 红N 并不这么做，你也可以随便写你想写的

SHOW_ABLUP_SELECT 结束后会跳转至 USERABLUP 函数 同样是一个自带 INPUT 的函数，本是用来处理之前选择要提升的能力的，你可以随便写你想写的

总有一个选项要跳出这个流程

;进入 EVENTTURNEND 函数

BEGIN TURNEND

EVENTTURNEND 函数是最后一个函数，写一点结算之类的东西吧，什么也不写也可以吧，总之在最后请务必写上

BEGIN SHOP

回到商店页面吧，这样就完成了一个游戏周期了

接下来会不停循环，直到你退出游戏。

# 尾声

到这里就结束了，作为基础教程，大概是把能讲的都讲了，利用这些知识，基本上能写出一个简单的ERA游戏了

努力成为一个ERA游戏的作者吧，无论是做和谐的游戏，还是做和谐的游戏，都是可以的

将来有机会和兴趣，我会编写一个更加详细的拓展教程

本教程呢，因为是基础教程

所以有大量的指令不被提及讲解，想要了解更多指令，请移步储备库，搜索指令，另说，指令一般都有其相应的方法可以使用，请留意

注意到最开头的 [SKIPSTART] 和最末尾的 [SKIPEND] 了吗？
如果读取到 [SKIPSTART] 就会跳过之后的内容直到遇见 [SKIPEND] ~~

最后的最后，注意到 ; 符号了吗？
这是注释符
在 ; 号后的内容都不会被读取
但是如果在 PRINT 指令后就会被当成文本了

[SKIPEND]

## 术语表

### 启动模式

#### 普通模式

#### 解释模式

#### 调试模式

### 窗口与对话框（Window & Dialogue）

#### 主窗口（MainWindow）

#### 主控台（MainConsole）

#### 调试窗口（DebugWindow）

#### 调试控制台（DebugConsole）

#### 设定对话框（SettingDialogue）

#### 剪贴板对话框（ClipBoardDialogue）

### 函数

#### 命令

#### 函数

#### 事件函数

#### 预处理器（Processor）

#### 属性（预处理器（Processor））

#### 定义（预处理器（Processor））

### 行